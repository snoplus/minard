#!/usr/bin/env python
"""
The objective here is to retrieve and store baseline values into a redis db.
"""
import time, os, sys
import threading
from minard.timeseries import INTERVALS, EXPIRE
from redis import Redis
from snotdaq import MTC, Logger
from functools import wraps
import psycopg2

log = Logger()

DBToMTC = {"100H":"N100HI","100M":"N100MED","100L":"N100LO",
"20":"N20","20LB":"N20LB","ESUMH":"ESUMHI","ESUML":"ESUMLO",
"OWLEH":"OWLEHI","OWLEL":"OWLELO","OWLN":"OWLN"}

def PutBaselinesInDatabase(mtc):
    redis = Redis()
    p = redis.pipeline()
    now = int(time.time())

    baselines = {}
    for name, mtc_name in DBToMTC.iteritems():
        # mtc server returns baselines in mV so we divide by 1000 to convert
        # to volts.
        baselines[name] = float(mtc.send('threshmon %s' % mtc_name))/1000

    for interval in INTERVALS:
        p.incrby('ts:%i:%i:baseline-count' % (interval,now//interval),1)
        p.expire('ts:%i:%i:baseline-count' % (interval,now//interval),interval*EXPIRE);
        for name, baseline in baselines.iteritems():
            key = 'ts:%i:%i:%s' % (interval,now//interval,name+"-Baseline")
            p.incrbyfloat(key,baseline)
            p.expire(key,interval*EXPIRE)
        p.execute()

def get_database_pool(db_host, db_name, db_user, db_pass):
    """
    Return the database connection pool.
    """
    pool = None
    try:
        if db_pass is None:
            pool = ThreadedConnectionPool(1, 5, host=db_host, database=db_name, \
                                          user=db_user)
        else:
            pool = ThreadedConnectionPool(1, 5, host=db_host, database=db_name, \
                                          user=db_user, password=db_pass)
    except Exception as e:
        log.warn("error connecting to the database: %s" % str(e))

    return pool

def post_heartbeat(pool):
    """
    Post the baseline monitor heartbeat
    """
    conn = None
    try:
        conn = pool.getconn()
        cursor = conn.cursor()
        cursor.execute("SELECT post_heartbeat('baseline_monitor')")
        cursor.close()
        conn.commit()
    except Exception as e:
        warning = "Could not post heartbeat to database. Reason: %s." % str(e)
        log.warn(warning)
    finally:
        pool.putconn(conn) if conn else None

    # Post heartbeat every 8 seconds
    t = threading.Timer(8.0, post_heartbeat,[pool])
    t.daemon = True
    t.start()

def daemonize():
    pid = os.fork()
    if pid>0:
        #kill the parent
        sys.exit(0)

    os.chdir("/")
    os.setsid()
    os.umask(0)
    devNull = open(os.devnull,'w')
    sys.stdout = devNull
    sys.stderr = devNull

if __name__ == '__main__':
    import argparse
    import socket

    parser = argparse.ArgumentParser()
    parser.add_argument("host", nargs='?',
                        help="hostname of the MTC server whence the baselines can be retrieved.",
                        default='sbc.sp.snolab.ca')
    parser.add_argument("--enable-logging",
                        help="Enables sending errors to log server",
                        action="store_true")
    parser.add_argument("--logfile", default=None, help="filename for log file")
    parser.add_argument("--log-server",
                        help="hostname of the log server.",
                        default="minard.sp.snolab.ca")
    parser.add_argument("--log-port",
                        help="Set the port the log server is at.",
                        type=int, default=4001)
    parser.add_argument("--loop-forever",
                        help="Loops infinitely with 0.5 second period",
                        action="store_true")
    parser.add_argument("-d", "--daemonize", help="Runs in background",
                        action="store_true")
    parser.add_argument('--db-user', help='database username',
                        default='operator')
    parser.add_argument('--db-pass', help='database password',
                        default=None)
    parser.add_argument('--db-host', help='database hostname',
                        default='dbug.sp.snolab.ca')
    parser.add_argument('--db-name', help='database name',
                        default='detector')


    args = parser.parse_args()

    if args.daemonize:
        try:
            daemonize()
        except OSError,e:
            sys.stderr.write("Failed to create fork: %d (%s)\n" % \
                (e.errno,e.strerror))
            sys.exit(1)

    if args.logfile:
        log.set_logfile(args.logfile)

    if args.enable_logging:
        try:
            log.connect("BaselineMonitor", args.log_server, args.log_port)
        except Exception as e:
            sys.stderr.write("failed to connect to log server at %s: %s\n" % \
                             (args.log_server, str(e)))
            sys.stderr.flush()

    log.notice("connecting to mtc server at %s..." % args.host)

    pool = get_database_pool(args.db_host, args.db_name, 
                             args.db_user, args.db_pass)
    post_heartbeat(pool)

    while True:
        try:
            mtc = MTC(args.host)
        except socket.timeout as e:
            time.sleep(10)
            continue
        log.notice("connected")
        break

    # Flag to help reduce warning spam
    did_warn = False

    if args.loop_forever:
        while True:
            try:
                PutBaselinesInDatabase(mtc)
            except KeyboardInterrupt:
                break
            except Exception as e:
                if not did_warn:
                    log.warn("couldn't update MTCA baselines: %s" % str(e))
                    did_warn = True
                time.sleep(60)
            else:
                did_warn = False
                time.sleep(0.5)
    else:
        try:
            PutBaselinesInDatabase(mtc)
        except Exception as e:
            log.warn("couldn't update MTCA baselines: %s" % str(e))
